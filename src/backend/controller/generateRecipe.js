import { GoogleGenAI } from "@google/genai";
import { ElevenLabsClient, play } from '@elevenlabs/elevenlabs-js';
import { Readable } from 'stream';
import 'dotenv/config';

import multer from 'multer'

const upload = multer({storage: multer.memoryStorage()})

const ai = new GoogleGenAI(process.env.GEMINI_API_KEY);

const elevenLabs = new ElevenLabsClient({
    apiKey: process.env.ELEVENLABS_API_KEY,
});

// array of contents: image part, and a text prompt
async function generateText(contents) {
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents,
    });
    return response.text;
  } catch (error) {
    console.error("Gemini API Error: ", error);
    return "Error encountered by AI.";
  }
}


// generateText("Give me a recipe for making crispy chicken")


// export async function generateAudio(req, res) {
//     const {text, voiceId} = req.body;

//     if (!text || !voiceId){
//         return res.status(400).json({ error: 'Text and voiceId are required.'});
//     }

//     try {
//         const audio = await elevenLabs.generateAudio({voice: voiceId, text: text, model_id: 'eleven_monolingual_v1'});
//         res.set({
//             'Content-Type': 'audio/mpeg',
//             'Content-Length': audio.length,
//             'Cache-Control': 'no-cache', 
//         });
//         res.status(200).send(audio);
//     }
//     catch (error) {
//         console.error('ElevenLabs API Error:', error);
//         res.status(500).json({ error: 'Failed to generate audio.' });
//     }
// }


// export async function generateAndReadRecipe(req, res) {
//     const prompt = "Give me a recipe for making crispy chicken";

//     try {
//         const textResult = await generateText(prompt);

//         if (textResult.startsWith("Error encountered by ai.")){
//             return res.status(500).json({error: textResult});
//         }

//         const audio = await elevenLabs.generate({
//             voice: process.env.DEFAULT_VOICE_ID,
//             text: textResult, // Use the text generated by Gemini
//             model_id: 'eleven_monolingual_v1',
//         });
  
//         res.set({
//             'Content-Type': 'audio/mpeg',
//             'Content-Length': audio.length,
//             'Cache-Control': 'no-cache',
//         });
//         res.status(200).send(audio);
//     } catch (error) {
//         console.error('Combined API Error:', error);
//         res.status(500).json({ error: 'Failed to generate and read the recipe.' });
//     }
// }

export async function audioGen(req, res) {
    const prompt = await generateText("Give me a recipe for making crispy chicken but make it short and sweet");
    // const prompt = "happy birthday to youuuu happy birthday to youuuuuu"
    const voiceId = process.env.DEFAULT_VOICE_ID;

    try {
        const audio = await elevenLabs.textToSpeech.convert(voiceId, {
            text: prompt,
            modelId: 'eleven_multilingual_v2',
            outputFormat: 'mp3_44100_128',
        });

        const reader = audio.getReader();
        const stream = new Readable({
            async read() {
                const { done, value } = await reader.read();
                if (done) {
                    this.push(null);
                } else {
                    this.push(value);
                }
            },
        });

        res.set({
            'Content-Type': 'audio/mpeg',
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0',
            'Transfer-Encoding': 'chunked'
        });

        // Stream the audio to the response
        stream.pipe(res);

        stream.on('error', (err) => {
            console.error('ElevenLabs Stream Error:', err);
            if (!res.headersSent) {
                res.status(500).send('Audio generation failed.');
            }
        });
    } catch(error) {
        console.error('ElevenLabs API Error:', error);
        if (!res.headersSent) {
            res.status(500).json({ error: 'Failed to generate speech.' });
        }
    }
}

export default {
    // generateAndReadRecipe,
    // generateAudio,
    audioGen,
    generateText


}